stages:
  - validate
  - test
  - build
  - pre-deploy
  - deploy
  - post-deploy

variables:
  DEPLOY_PATH: "/var/www/flask_helpdesk"
  SERVICE_NAME: "flask-helpdesk"
  BACKUP_PATH: "/var/backups/flask_helpdesk"
  PYTHON_VERSION: "3.11"
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"
  AFTER_SCRIPT_IGNORE_ERRORS: false

cache:
  paths:
    - .cache/pip/

# ============ ЭТАП 1: ВАЛИДАЦИЯ ============
validate_project:
  stage: validate
  image: python:3.11-slim
  script:
    - echo "🔍 Проверка структуры проекта..."
    - |
      if [ ! -f "requirements.txt" ]; then
        echo "❌ Файл requirements.txt не найден"
        exit 1
      fi
      if [ ! -f "app.py" ]; then
        echo "❌ Файл app.py не найден"
        exit 1
      fi
      if [ ! -f "flask-helpdesk.service" ]; then
        echo "❌ Файл flask-helpdesk.service не найден"
        exit 1
      fi
    - echo "✅ Структура проекта валидна"
    - echo "📊 Статистика проекта:"
    - find . -name "*.py" | wc -l | xargs echo "Python файлов:"
    - find . -name "*.html" | wc -l | xargs echo "HTML шаблонов:"
    - find . -name "*.css" | wc -l | xargs echo "CSS файлов:"
    - find . -name "*.js" | wc -l | xargs echo "JavaScript файлов:"
  only:
    - main
    - develop
    - merge_requests

# ============ ЭТАП 2: ТЕСТИРОВАНИЕ ============
test_dependencies:
  stage: test
  image: python:3.11-slim
  before_script:
    - apt-get update -qy
    - apt-get install -y gcc g++ libffi-dev libssl-dev default-libmysqlclient-dev pkg-config
    - python -m venv venv
    - source venv/bin/activate
    - pip install --upgrade pip
  script:
    - source venv/bin/activate
    - echo "🧪 Тестирование зависимостей..."
    - pip install -r requirements.txt
    - echo "✅ Все зависимости установлены успешно"
  only:
    - main
    - develop
    - merge_requests

test_flask_import:
  stage: test
  image: python:3.11-slim
  script:
    - echo "🧪 Проверка импорта Flask приложения..."
    - pip install --upgrade pip
    - pip install -r requirements.txt
    - python -c "from blog import create_app; print('✅ Flask приложение импортируется корректно')"
    - python -c "import flask; print('Flask версия:', flask.__version__)"
  only:
    - main
    - develop
    - merge_requests

# ============ ЭТАП 3: СБОРКА ============
build_deployment_package:
  stage: build
  image: python:3.11-slim
  script:
    - echo "📦 Создание МИНИМАЛЬНОГО deployment пакета (v2)..."
    - apt-get update && apt-get install -y rsync
    - mkdir -p deployment_package
    - |
      # НОВАЯ СТРАТЕГИЯ: Включаем только необходимые файлы
      echo "📦 РАДИКАЛЬНО НОВЫЙ ПОДХОД: Создаем минимальный deployment пакет..."

      # Создаем структуру
      mkdir -p deployment_package/blog

      # Копируем только необходимые файлы
      cp app.py deployment_package/
      cp wsgi.py deployment_package/
      cp requirements.txt deployment_package/
      cp flask-helpdesk.service deployment_package/
      cp config.py deployment_package/
      cp .flaskenv deployment_package/
      cp config.ini deployment_package/
      cp mysql_db.py deployment_package/
      cp redmine.py deployment_package/
      cp erp_oracle.py deployment_package/

      # Копируем папку blog (основное приложение)
      rsync -av --exclude='__pycache__' --exclude='*.pyc' blog/ deployment_package/blog/

      echo "✅ Минимальный пакет создан - только необходимые файлы"
      echo "🔍 ДИАГНОСТИКА: Проверяем что НЕ включено в пакет:"
      echo "❌ app_err.log - $(if [ -f deployment_package/app_err.log ]; then echo 'НАЙДЕН!'; else echo 'исключен'; fi)"
      echo "❌ logs/ - $(if [ -d deployment_package/logs ]; then echo 'НАЙДЕНА!'; else echo 'исключена'; fi)"
      echo "❌ scripts/ - $(if [ -d deployment_package/scripts ]; then echo 'НАЙДЕНА!'; else echo 'исключена'; fi)"
    - |
      # Финальная очистка минимального пакета
      find deployment_package/ -name "*.pyc" -delete
      find deployment_package/ -name "__pycache__" -type d -exec rm -rf {} + 2>/dev/null || true
      find deployment_package/ -name ".DS_Store" -delete
      echo "🧹 Очистка завершена"
    - echo "✅ Deployment пакет создан и оптимизирован"
    - echo "📊 Размер пакета до сжатия:"
    - du -sh deployment_package/
    - echo "📋 Содержимое пакета (топ-уровень):"
    - ls -la deployment_package/
    - echo "📈 Количество файлов:"
    - find deployment_package/ -type f | wc -l
    - |
      # Создаем сжатый архив для экономии места при передаче
      echo "🗜️ Создаем сжатый архив..."
      tar -czf deployment_package.tar.gz -C deployment_package .
      echo "📊 Размер сжатого архива:"
      ls -lh deployment_package.tar.gz
      echo "📉 Коэффициент сжатия:"
      ORIGINAL_SIZE=$(du -sb deployment_package | cut -f1)
      COMPRESSED_SIZE=$(stat -f%z deployment_package.tar.gz 2>/dev/null || stat -c%s deployment_package.tar.gz)
      echo "Оригинал: $(numfmt --to=iec $ORIGINAL_SIZE)"
      echo "Сжатый: $(numfmt --to=iec $COMPRESSED_SIZE)"
      echo "Экономия: $(( (ORIGINAL_SIZE - COMPRESSED_SIZE) * 100 / ORIGINAL_SIZE ))%"
  artifacts:
    paths:
      - deployment_package/
      - deployment_package.tar.gz
    expire_in: 1 hour
    # Ограничиваем размер артефакта
    when: on_success
  only:
    - main

# ============ ЭТАП 4: ПРЕДВАРИТЕЛЬНАЯ ПРОВЕРКА ============
pre_deploy_checks:
  stage: pre-deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client curl
    - |
      # Проверяем наличие необходимых переменных
      echo "🔍 Проверка переменных окружения..."
      if [ -z "$SSH_PRIVATE_KEY" ]; then
        echo "❌ SSH_PRIVATE_KEY не установлен"
        exit 1
      fi
      if [ -z "$DEPLOY_SERVER" ]; then
        echo "❌ DEPLOY_SERVER не установлен"
        echo "ℹ️ Пропускаем проверки деплоя - переменные не настроены"
        exit 0
      fi
      if [ -z "$DEPLOY_USER" ]; then
        echo "❌ DEPLOY_USER не установлен"
        echo "ℹ️ Пропускаем проверки деплоя - переменные не настроены"
        exit 0
      fi
      echo "✅ Все необходимые переменные установлены"
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -H $DEPLOY_SERVER >> ~/.ssh/known_hosts
  script:
    - echo "🔍 Предварительные проверки сервера..."
    - |
      # Проверка SSH подключения
      if ! ssh $DEPLOY_USER@$DEPLOY_SERVER "echo 'SSH соединение OK'"; then
        echo "❌ Ошибка SSH подключения"
        exit 1
      fi
    - |
      # Проверка свободного места (минимум 1GB)
      AVAILABLE_SPACE=$(ssh $DEPLOY_USER@$DEPLOY_SERVER "df $DEPLOY_PATH | awk 'NR==2 {print \$4}'")
      if [ "$AVAILABLE_SPACE" -lt 1048576 ]; then
        echo "❌ Недостаточно свободного места на сервере"
        exit 1
      fi
      echo "✅ Свободного места: $(($AVAILABLE_SPACE / 1024)) MB"
    - |
      # Проверка прав доступа
      ssh $DEPLOY_USER@$DEPLOY_SERVER "
        if [ ! -w '$DEPLOY_PATH' ]; then
          echo '❌ Нет прав записи в $DEPLOY_PATH'
          exit 1
        fi
        echo '✅ Права доступа корректны'
      "
    - |
      # Проверка статуса сервиса
      ssh $DEPLOY_USER@$DEPLOY_SERVER "
        if ! sudo systemctl is-active --quiet $SERVICE_NAME; then
          echo '⚠️ Сервис $SERVICE_NAME не запущен, но это нормально для первого деплоя'
        else
          echo '✅ Сервис $SERVICE_NAME активен'
        fi
      "
    - echo "✅ Все предварительные проверки пройдены"
  only:
    - main

# ============ ЭТАП 5: ДЕПЛОЙ ============
deploy_to_server:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client rsync
    - |
      # Проверяем наличие необходимых переменных
      echo "🔍 Проверка переменных окружения для деплоя..."
      if [ -z "$SSH_PRIVATE_KEY" ] || [ -z "$DEPLOY_SERVER" ] || [ -z "$DEPLOY_USER" ]; then
        echo "❌ Не все переменные деплоя настроены"
        echo "ℹ️ Пропускаем деплой - переменные не настроены"
        exit 0
      fi
      echo "✅ Все переменные деплоя установлены"
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -H $DEPLOY_SERVER >> ~/.ssh/known_hosts
  script:
    - echo "🚀 Начинаем деплой на сервер..."
    - |
      # Создаем бэкап существующего проекта
      ssh $DEPLOY_USER@$DEPLOY_SERVER "
        echo '💾 Создаем бэкап...'
        if [ -d '$DEPLOY_PATH' ]; then
          sudo mkdir -p $BACKUP_PATH
          sudo cp -r $DEPLOY_PATH $BACKUP_PATH/backup_\$(date +%Y%m%d_%H%M%S)
          echo '✅ Бэкап создан'
        fi
      "
    - |
      # Останавливаем сервис
      ssh $DEPLOY_USER@$DEPLOY_SERVER "
        echo '⏹️ Останавливаем сервис...'
        if sudo systemctl is-active --quiet $SERVICE_NAME; then
          sudo systemctl stop $SERVICE_NAME
          echo '✅ Сервис остановлен'
        else
          echo 'ℹ️ Сервис уже остановлен'
        fi
      "
    - |
      # Убеждаемся что все права правильные перед синхронизацией
      ssh $DEPLOY_USER@$DEPLOY_SERVER "
        echo '🔧 Исправляем права доступа перед деплоем...'
        sudo mkdir -p $DEPLOY_PATH
        sudo chown -R www-data:www-data $DEPLOY_PATH
        sudo chmod -R 755 $DEPLOY_PATH
      "
    - |
      # Синхронизируем файлы (используем сжатый архив если он меньше)
      echo '📁 Синхронизируем файлы...'
      if [ -f "deployment_package.tar.gz" ]; then
        echo '🗜️ Используем сжатый архив для передачи'
        scp deployment_package.tar.gz $DEPLOY_USER@$DEPLOY_SERVER:/tmp/
        ssh $DEPLOY_USER@$DEPLOY_SERVER "
          cd $DEPLOY_PATH
          sudo rm -rf ./*
          sudo tar -xzf /tmp/deployment_package.tar.gz -C $DEPLOY_PATH
          sudo rm -f /tmp/deployment_package.tar.gz
          echo '✅ Архив распакован'
        "
      else
        echo '📁 Используем обычную синхронизацию'
        rsync -avz --delete deployment_package/ $DEPLOY_USER@$DEPLOY_SERVER:$DEPLOY_PATH/
      fi
    - |
      # Исправляем права после синхронизации
      ssh $DEPLOY_USER@$DEPLOY_SERVER "
        echo '🔧 Исправляем права доступа после синхронизации...'
        sudo chown -R www-data:www-data $DEPLOY_PATH
        sudo find $DEPLOY_PATH -type d -exec chmod 755 {} \;
        sudo find $DEPLOY_PATH -type f -exec chmod 644 {} \;
        sudo chmod +x $DEPLOY_PATH/app.py
      "
    - |
      # Пересоздаем виртуальное окружение
      ssh $DEPLOY_USER@$DEPLOY_SERVER "
        echo '🐍 Настраиваем Python окружение...'
        cd $DEPLOY_PATH

        # Удаляем старое venv если есть
        if [ -d 'venv' ]; then
          sudo rm -rf venv
        fi

        # Создаем новое venv
        sudo python3 -m venv venv --prompt flask_helpdesk
        sudo chown -R www-data:www-data venv/

        # Активируем и устанавливаем зависимости
        sudo -u www-data venv/bin/pip install --upgrade pip
        sudo -u www-data venv/bin/pip install -r requirements.txt

        echo '✅ Python окружение настроено'
      "
    - |
      # Тестируем приложение
      ssh $DEPLOY_USER@$DEPLOY_SERVER "
        echo '🧪 Тестируем приложение...'
        cd $DEPLOY_PATH

        # Проверяем что приложение может быть импортировано
        sudo -u www-data venv/bin/python -c 'from blog import create_app; print(\"✅ Приложение импортируется корректно\")'
      "
    - |
      # Настраиваем systemd сервис
      ssh $DEPLOY_USER@$DEPLOY_SERVER "
        echo '⚙️ Настраиваем systemd сервис...'

        # Копируем service файл
        sudo cp $DEPLOY_PATH/flask-helpdesk.service /etc/systemd/system/
        sudo systemctl daemon-reload
        sudo systemctl enable $SERVICE_NAME

        echo '✅ Systemd сервис настроен'
      "
    - |
      # Финальное исправление прав
      ssh $DEPLOY_USER@$DEPLOY_SERVER "
        echo '🔧 Финальное исправление прав...'
        sudo chown -R www-data:www-data $DEPLOY_PATH
        sudo chmod -R 755 $DEPLOY_PATH

        # Особые права для важных файлов
        sudo chmod 644 $DEPLOY_PATH/requirements.txt
        sudo chmod 755 $DEPLOY_PATH/app.py

        echo '✅ Все права исправлены'
      "
    - |
      # Запускаем сервис
      ssh $DEPLOY_USER@$DEPLOY_SERVER "
        echo '▶️ Запускаем сервис...'
        sudo systemctl start $SERVICE_NAME

        # Ждем запуска
        sleep 5

        if sudo systemctl is-active --quiet $SERVICE_NAME; then
          echo '✅ Сервис запущен успешно'
        else
          echo '❌ Ошибка запуска сервиса'
          sudo systemctl status $SERVICE_NAME
          exit 1
        fi
      "
    - echo "🎉 Деплой завершен успешно!"
  only:
    - main

# ============ ЭТАП 6: ПОСТ-ДЕПЛОЙ ПРОВЕРКИ ============
post_deploy_verification:
  stage: post-deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client curl
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -H $DEPLOY_SERVER >> ~/.ssh/known_hosts
  script:
    - echo "🔍 Проверяем результат деплоя..."
    - |
      # Проверка статуса сервиса
      ssh $DEPLOY_USER@$DEPLOY_SERVER "
        echo '📊 Статус сервиса:'
        sudo systemctl status $SERVICE_NAME --no-pager

        echo '📝 Последние логи:'
        sudo journalctl -u $SERVICE_NAME --no-pager -n 10
      "
    - |
      # Проверка HTTP ответа
      ssh $DEPLOY_USER@$DEPLOY_SERVER "
        echo '🌐 Проверяем HTTP ответ...'
        if curl -f -s -o /dev/null http://localhost:5000; then
          echo '✅ Приложение отвечает по HTTP'
        else
          echo '❌ Приложение не отвечает по HTTP'
          exit 1
        fi
      "
    - |
      # Проверка прав доступа
      ssh $DEPLOY_USER@$DEPLOY_SERVER "
        echo '🔐 Проверяем права доступа:'
        ls -la $DEPLOY_PATH/
        echo '🐍 Права venv:'
        ls -la $DEPLOY_PATH/venv/
      "
    - |
      # Финальный отчет
      ssh $DEPLOY_USER@$DEPLOY_SERVER "
        echo '📈 ОТЧЕТ О ДЕПЛОЕ:'
        echo '=================='
        echo 'Сервис:' \$(sudo systemctl is-active $SERVICE_NAME)
        echo 'PID:' \$(sudo systemctl show $SERVICE_NAME --property=MainPID --value)
        echo 'Время запуска:' \$(sudo systemctl show $SERVICE_NAME --property=ActiveEnterTimestamp --value)
        echo 'Использование памяти:' \$(sudo systemctl show $SERVICE_NAME --property=MemoryCurrent --value | numfmt --to=iec)
        echo '=================='
      "
    - echo "✅ Пост-деплой проверки завершены успешно!"
  only:
    - main

# ============ ROLLBACK ЗАДАЧА (ВРУЧНУЮ) ============
rollback_deployment:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -H $DEPLOY_SERVER >> ~/.ssh/known_hosts
  script:
    - echo "🔄 Выполняем откат к предыдущей версии..."
    - |
      ssh $DEPLOY_USER@$DEPLOY_SERVER "
        # Останавливаем текущий сервис
        sudo systemctl stop $SERVICE_NAME

        # Находим последний бэкап
        LAST_BACKUP=\$(ls -t $BACKUP_PATH/backup_* | head -n 1)

        if [ -z \"\$LAST_BACKUP\" ]; then
          echo '❌ Бэкапы не найдены'
          exit 1
        fi

        echo '🔄 Восстанавливаем из бэкапа:' \$LAST_BACKUP

        # Удаляем текущую версию и восстанавливаем бэкап
        sudo rm -rf $DEPLOY_PATH
        sudo cp -r \$LAST_BACKUP $DEPLOY_PATH
        sudo chown -R www-data:www-data $DEPLOY_PATH

        # Запускаем сервис
        sudo systemctl start $SERVICE_NAME

        echo '✅ Откат выполнен успешно'
      "
  when: manual
  only:
    - main
