# Проект Python Flask Helpdesk

## Описание проекта
Веб-приложение для работы с системой заявок, интегрированное с Redmine и Cisco Finesse. Позволяет отслеживать статусы заявок, получать уведомления об изменениях, управлять задачами, запускать колл-центры.

## Журнал звонков
Модуль отображает историю телефонных звонков за выбранный период (по умолчанию - текущий день). Ключевые возможности:
- **Отображение списка звонков:** Показывает таблицу с информацией о звонках: номер телефона, время, оператор, результат (успех/неудача/др.), тип звонка.
- **Интерактивные элементы:**
    - Кнопка **"Карта клиента"**: Открывает модальное окно с детальной информацией о клиенте, если она доступна.
    - Кнопка **"Инфо"**: Открывает модальное окно с информацией об агентстве, связанном со звонком (адрес, телефоны, менеджер, район, прием карт и т.д.). Адрес агентства является кликабельной ссылкой для открытия на Яндекс Картах.
- **Фильтрация и поиск:** Позволяет фильтровать список звонков по номеру телефона, имени оператора и выбирать конкретную дату для просмотра истории.
- **Статистика:** Отображает общее количество звонков за выбранный день и статистику по количеству звонков на каждого оператора.
- **Динамическое обновление:** Журнал можно обновить вручную с помощью кнопки обновления или автоматически при смене даты в фильтре.
- **Получение данных:** Информация для журнала загружается через API-маршрут `/api/moscow-calls`.

## Отображение операторов Cisco Finesse
Данный модуль предназначен для супервизоров и позволяет отслеживать текущее состояние операторов контакт-центра, работающих через систему Cisco Finesse.
- **Требуется авторизация:** Для просмотра статусов операторов необходимо выполнить вход с учетными данными Cisco Finesse через специальное модальное окно.
- **Отображение статусов:** Показывает список операторов, сгруппированных по командам (если применимо).
- **Информация об операторе:** Для каждого оператора отображается:
    - Имя оператора
    - Текущий статус (Готов, Не готов, Разговор, Постобработка, Выход) с соответствующим цветовым индикатором.
    - Добавочный номер (extension).
- **Обновление данных:** Статусы операторов можно обновить вручную с помощью кнопки обновления.
- **Обработка ошибок:** Модуль информирует пользователя об ошибках подключения к Finesse (например, при проблемах с VPN) или ошибках авторизации.
- **Интеграция:** Получает данные о статусах операторов через API-маршрут `/finesse/agents/status`.
- **Интерфейс:** Панель операторов отображается в виде сворачиваемого аккордеона.

## Технологии
- Python 3.x
- Flask
- SQLite
- SQLAlchemy
- Redmine API
- XMPP (для уведомлений)
- JavaScript/jQuery
- Bootstrap
- Cisco Finesse Development

## Установка и запуск

### Предварительные требования
- Python 3.x
- pip
- Virtual Environment
- Доступ к Redmine
- VPN подключение для работы с ERP

### Установка зависимостей

python -m venv env
source env/bin/activate # для Linux/Mac
env\Scripts\activate # для Windows
pip install -r requirements.txt

## Разработка

### Основные функции
- Авторизация через ERP
- Просмотр и управление заявками
- Система уведомлений
- Отчеты и статистика
- Интеграция с Redmine
- XMPP уведомления

### Работа с уведомлениями
- Настройка периодичности проверки
- Vacuum-IM интеграция
- Очистка уведомлений

### Структура проекта
blog/
├── static/ # Статические файлы (CSS, JavaScript)
├── templates/ # HTML шаблоны
├── main/ # Основные маршруты
├── user/ # Функционал пользователей
└── models.py # Модели данных
### Конфигурация
1. Создайте файл `config.ini` в корневой директории
2. Настройте подключение к базам данных:
   - MySQL (Redmine)
   - SQLite (локальная БД)
3. Настройте XMPP для уведомлений

## Тестирование
Описание процесса тестирования и инструкции

## Известные проблемы
- Возможные конфликты при одновременном доступе к SQLite
- Необходимость VPN для доступа к ERP
- Таймауты при работе с Redmine API

## Поддержка
Инструкции по созданию тикетов и обращению в техподдержку

### Система уведомлений

#### Особенности
- Автоматическое обновление каждые 30 секунд
- Адаптивное отображение количества уведомлений
- Поддержка двух типов уведомлений:
  - Изменения статуса заявок
  - Новые комментарии

#### Стилизация уведомлений
- Компактное отображение при большом количестве
- Вертикальная прокрутка при переполнении
- Максимальная высота контейнера: 700px
- Адаптивная ширина до 800px
- Поддержка HTML-форматирования в тексте уведомлений

#### Очистка уведомлений
- Групповое удаление всех уведомлений
- Автоматическая очистка после прочтения
- Подтверждение успешного удаления

#### Настройка внешнего вида

# Общее назначение Blueprint "calls" колл-центр Вильнюс

Blueprint "calls" отвечает за обработку всех запросов, связанных с телефонными звонками в системе. Он реализует бизнес-логику для:

- Записи информации о входящих звонках
- Получения статистики звонков из базы данных
- Обработки завершения звонков
- Обновления информации о звонках (например, темы вызова)
- Получения детальных данных об агентстве, привязанном к звонку (с использованием внешнего XML-сервиса)

Для обеспечения доступа с разных доменов используется CORS, что позволяет принимать запросы на адреса вида `/contact-center/vilnius/tel/` от любых источников.


## Основные функции и маршруты

### 1. `/contact-center/vilnius`
**Назначение:**
Эта конечная точка используется для отображения главной страницы контакт-центра.

**Что происходит:**
- Вызывается функция `get_last_calls_all()`, которая извлекает последние записи звонков из таблицы `T_CALL_INFO`.
- Полученные данные (например, последний звонок и список последних пятерок звонков) передаются в шаблон `contact_center.html` для отображения пользователю.


### 2. `/contact-center/vilnius/tel/` и `/contact-center/vilnius/tel/<tel>/`
**Назначение:**
Эти маршруты являются основными точками входа для обработки звонков, поступающих в систему.

**Что происходит:**
- В самом начале функция `queue_start_tel` фиксирует URL запроса в лог-файле (с помощью функции `write_log`).
- Если в параметрах запроса присутствует `type=endcall`, происходит вызов функции `handle_endcall()`, которая обновляет запись звонка, фиксируя время его завершения.
- Если параметр `ani` (номер телефона) присутствует в GET-параметрах, то:
  - Извлекается значение ANI (обычно номер без пробелов) и дополняется префиксом.
  - Проводится попытка получить идентификатор агентства через функцию `get_agency_id_by_ani()`. Если агентство не найдено (возвращается "0"), отображается шаблон `agency_not_found.html`.
  - При наличии GET-параметра `type=newcall` запускается обработка нового звонка через функцию `handle_newcall()`, куда передаются такие параметры, как номер куратора, идентификатор агентства, ANI и сам номер в числовом представлении.

**В функции `handle_newcall` происходит:**
- Запись информации о звонке в базу данных (`record_stat_to_db()`).
- Запрос к внешнему XML-сервису для получения информации об агентстве (`parse_xml_data()`).
- Получение истории звонков для данного агентства (`get_last_calls()`).
- Сохранение данных в сессии Flask и рендеринг `agency_data.html`.


### 3. `/call-show/<string:agency_name>/`
**Назначение:**
Предоставляет возможность повторного отображения информации о звонке и деталях агентства.

**Что происходит:**
- Из сессии извлекаются данные агентства, идентификатор и запись звонка (`pk_record`).
- Если идентификатор агентства корректный, вызывается `get_last_calls()` для получения истории звонков.
- Сформированная информация передается в шаблон `agency_data.html` для показа пользователю.


### 4. `/update_call_theme` (метод POST)
**Назначение:**
Позволяет обновлять тему (subject) активного звонка.

**Что происходит:**
- Из сессии извлекается `pk_record` текущего звонка.
- Полученный из формы параметр `theme` используется для обновления записи в таблице `T_CALL_INFO`.
- Выполняется SQL-запрос для обновления, после чего возвращается JSON-ответ с результатом операции.


### 5. `/get_latest_calls`
**Назначение:**
Предоставляет API для получения последних звонков в виде JSON-ответа.

**Что происходит:**
- Из таблицы звонков извлекаются последние записи (`get_last_calls_all()`).
- Форматируются данные звонков (время начала и окончания в читаемом формате).
- Данные возвращаются в виде JSON для динамического обновления списка звонков на клиентской стороне.


## Вспомогательные функции и логика

### Логирование:
- `write_log()` записывает информацию о запросах в `stat.log` для отслеживания входящих звонков и действий.

### Работа с базой данных:
- `get_session_with_bind()`, `record_stat_to_db()`, `get_pk_record()` и `session_scope()` обеспечивают взаимодействие с Oracle CRM и Sales Schema.

### Обработка завершения звонка:
- `handle_endcall()` обновляет время завершения через `write_end_call()`.

### Интеграция через XML-сервис:
- `authenticate_and_get_session_id()`, `fetch_agency_data()`, `parse_xml_data()` и вспомогательные функции (`extract_agency_data()`, `extract_contact_info()`, `extract_managers()`) обеспечивают запросы к внешнему XML-сервису.
- `get_xml_agency_not_blacklist()` проверяет, не находится ли агентство в черном списке.

### Обновление информации об агентстве:
- `write_agency_manager()` и `write_agency_name()` обновляют соответствующие поля в записи звонка после получения данных из XML.


## Итог
Blueprint "calls" осуществляет:

- Прием входящих запросов и регистрацию звонков,
- Проверку и получение информации об агентстве (через внутренние модели и внешние XML-сервисы),
- Отображение информации в виде HTML-страниц (dashboard контакт-центра, страница с данными агентства),
- Обновление данных звонка (завершение звонка, обновление темы),
- Предоставление API для динамического отображения статистики звонков.


Как реализован функционал мониторинга соединения с Finesse
**Общий принцип работы:**

Страница предназначена для визуализации состояния сетевого соединения между различными точками (сервер Helpdesk, ваш браузер) и целевым сервером Finesse (`uccx1.teztour.com`). Она использует комбинацию тестов, выполняемых на стороне сервера (бэкенд Flask) и на стороне клиента (ваш браузер), и отображает результаты в виде статус-карточек и графика истории. Данные периодически обновляются автоматически и могут быть обновлены вручную.

**Пошаговое описание функционала:**

1.  **Загрузка страницы:**
    *   Когда вы открываете страницу `/network-monitor`, Flask рендерит HTML-шаблон (`network_monitor.html`).
    *   В браузер загружается HTML-структура, CSS-стили и встроенный JavaScript-код.
    *   Сразу после загрузки DOM (`DOMContentLoaded`), JavaScript начинает работу.

2.  **Инициализация (JavaScript):**
    *   Вызывается функция `fetchStatus()`: Она отправляет запрос к серверному API (`/api/status`). Бэкенд Flask выполняет реальный пинг от сервера Helpdesk до Finesse, определяет статус (`excellent`, `good`, `average`, `poor`, `disconnected`) на основе времени отклика и возвращает результат (время, статус, метку времени). Этот результат используется для обновления карточки **"Сервер Helpdesk → Finesse"**.
    *   Вызывается функция `fetchPingHistory()`: Она отправляет запрос к серверному API (`/api/ping-history?target=finesse&limit=50`). Бэкенд Flask возвращает историю последних 50 результатов *серверного* пинга до Finesse. Эти данные используются для построения/обновления **графика** с помощью библиотеки Chart.js.
    *   Вызывается функция `performClientTest()`: Эта функция выполняется *в вашем браузере*. Она пытается отправить `HEAD` запрос напрямую к `https://uccx1.teztour.com/` с параметром `mode: 'no-cors'`.
        *   `mode: 'no-cors'` означает, что браузер не будет требовать специальных CORS-заголовков от Finesse и не сможет прочитать тело или статус ответа из соображений безопасности.
        *   Функция измеряет время (`performance.now()`) от начала запроса до получения *любого* ответа или ошибки.
        *   Результат (приблизительное время и статус "Доступен (приблизительно)" или "Нет связи / Ошибка") отображается на карточке **"Ваш браузер → Finesse"**. Статус "Доступен" здесь означает лишь отсутствие немедленной сетевой ошибки (вроде ошибки сертификата или таймаута), а не подтвержденный успешный ответ от Finesse.
    *   Устанавливается `setInterval`: Запускается таймер, который будет автоматически повторять шаги обновления каждые 10 секунд.

3.  **Автоматическое обновление (каждые 10 секунд):**
    *   Таймер вызывает функцию `performServerPing()`: Эта функция отправляет запрос к API (`/api/ping?target=finesse`), который заставляет бэкенд Flask выполнить *новый* пинг от сервера Helpdesk до Finesse. *После* этого серверного пинга, `performServerPing` вызывает `fetchStatus()` и `fetchPingHistory()`, чтобы обновить карточку "Сервер Helpdesk → Finesse" и график последними данными.
    *   Таймер также вызывает функцию `performClientTest()`, которая снова выполняет тест соединения из вашего браузера к Finesse и обновляет карточку "Ваш браузер → Finesse".

4.  **Работа кнопок:**
    *   **Кнопки выбора цели (сейчас только "Finesse"):**
        *   Предназначены для выбора цели, чья история пинга будет отображаться на графике.
        *   При нажатии: обновляется `currentTarget`, кнопка становится активной, вызывается `fetchPingHistory(target)`, чтобы загрузить и отобразить на графике историю пингов для выбранной цели (только *серверных* пингов).
    *   **Кнопка "Обновить":**
        *   При нажатии:
            *   Показывается анимация загрузки, кнопка блокируется.
            *   **Одновременно** запускаются:
                *   `performServerPing()`: инициирует новый *серверный* пинг, а затем обновляет серверную карточку и график.
                *   `performClientTest()`: инициирует новый *клиентский* тест и обновляет клиентскую карточку.
            *   После завершения обоих тестов анимация убирается, кнопка разблокируется.
        *   Эта кнопка позволяет получить самые свежие данные по обоим тестам немедленно, не дожидаясь автоматического обновления.

**Итог:**

*   **Левая карточка ("Сервер Helpdesk → Finesse")** показывает результат пинга с вашего веб-сервера до Finesse (надежный тест, если сервер настроен правильно).
*   **Правая карточка ("Ваш браузер → Finesse")** показывает результат попытки прямого соединения из вашего браузера до Finesse (менее надежный из-за `no-cors` и подвержен проблемам на стороне клиента, таким как ошибки сертификатов).
*   **График** показывает историю пингов **только** с сервера Helpdesk до Finesse.
*   **Кнопка "Обновить"** запускает оба теста вручную.
*   Все данные автоматически обновляются каждые 10 секунд.
