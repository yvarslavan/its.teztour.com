# Документация по CI/CD Пайплайну для Flask Helpdesk

Этот документ описывает полный жизненный цикл непрерывной интеграции и развертывания (CI/CD) для приложения Flask Helpdesk.

## 1. Архитектура Пайплайна

Пайплайн спроектирован как последовательность этапов (stages), где каждый следующий этап зависит от успешного выполнения предыдущего. Он автоматически запускается при изменениях в репозитории и управляет всем процессом — от проверки кода до развертывания на производственном сервере.

### 1.1. Стадии

Пайплайн состоит из 7 логических стадий:

1.  `validate`: Проверка синтаксиса кода для быстрого выявления очевидных ошибок.
2.  `test`: Запуск автоматизированных тестов для проверки логики приложения.
3.  `build`: Сборка приложения в готовый для развертывания пакет (артефакт).
4.  `pre-deploy`: Выполнение проверок на сервере перед развертыванием (наличие доступа, свободного места и т.д.).
5.  `deploy`: Развертывание новой версии приложения на производственном сервере.
6.  `post-deploy`: Проверка работоспособности приложения после развертывания.
7.  `rollback`: Ручной этап для отката к предыдущей стабильной версии в случае сбоя.

### 1.2. Задачи (Jobs)

Каждая стадия содержит одну или несколько задач (jobs), которые выполняют конкретные действия:
*   `validate_syntax` (на стадии `validate`)
*   `run_tests` (на стадии `test`)
*   `build_deployment_package` (на стадии `build`)
*   `pre_deploy_checks` (на стадии `pre-deploy`)
*   `deploy_to_server` (на стадии `deploy`)
*   `post_deploy_verification` (на стадии `post-deploy`)
*   `rollback_deployment` (на стадии `rollback`)

### 1.3. Артефакты

Ключевым элементом пайплайна является артефакт — **`deployment_package.tar.gz`**. Это сжатый архив, который создается на стадии `build`. Он содержит весь код приложения, шаблоны, статические файлы и зависимости, необходимые для работы. Этот артефакт передается между стадиями, гарантируя, что тестируется и развертывается одна и та же версия кода.

## 2. Подробное Описание Шагов Пайплайна

### 2.1. Валидация (`validate_syntax`)
*   **Триггер:** Запускается на коммиты в `main` и при создании Merge Request.
*   **Действие:** Проверяет все `.py` файлы на синтаксические ошибки с помощью `python -m py_compile`. Это быстрая и дешевая проверка, позволяющая отсеять грубые ошибки до запуска тестов.

### 2.2. Тестирование (`run_tests`)
*   **Триггер:** Запускается на коммиты в `main` и при создании Merge Request.
*   **Действие:** Устанавливает все зависимости из `requirements.txt` и запускает набор тестов с помощью `pytest`.
*   **Примечание:** Этот шаг помечен как `allow_failure: true`, что означает, что его провал не остановит пайплайн. Это может быть полезно на этапе внедрения тестов, но в будущем рекомендуется установить `false`.

### 2.3. Сборка (`build_deployment_package`)
*   **Триггер:** Только на коммиты в `main`.
*   **Действие:** Создает директорию `deployment_package/`, копирует в нее все необходимые для работы приложения файлы и папки. Затем упаковывает содержимое в архив `deployment_package.tar.gz`, который сохраняется как артефакт.

### 2.4. Предварительные проверки (`pre_deploy_checks`)
*   **Триггер:** Только на коммиты в `main`.
*   **Действие:** Подключается к серверу по SSH и выполняет ряд проверок:
    *   Наличие необходимых переменных окружения GitLab CI/CD.
    *   Успешность SSH-соединения.
    *   Наличие достаточного свободного места на диске.
    *   Наличие прав на запись в директорию деплоя (`/var/www/flask_helpdesk`), с попыткой автоматического исправления.
    Это важный шаг безопасности, который предотвращает деплой на неподготовленный сервер.

### 2.5. Деплой на продакшн (`deploy_to_server`)
*   **Триггер:** Только на коммиты в `main`, выполняется после всех проверок.
*   **Примечание по окружениям:** Текущий пайплайн выполняет деплой напрямую в **production**. Отдельного **staging** окружения не предусмотрено.
*   **Действия:**
    1.  **Создание бэкапа:** Копирует текущую версию приложения в `/var/backups/flask_helpdesk`.
    2.  **Остановка сервиса:** Останавливает `systemd` сервис `flask-helpdesk`.
    3.  **Синхронизация файлов:** Новая версия из архива распаковывается во временную директорию, а затем с помощью `rsync` синхронизируется в рабочую папку. **Ключевой момент:** используется флаг `--exclude 'blog/db'`, который предотвращает удаление или изменение директории с базой данных, обеспечивая сохранность данных. Флаг `--delete` удаляет старые файлы кода, которых нет в новой версии.
    4.  **Настройка окружения:** Пересоздает виртуальное окружение `venv` и устанавливает зависимости из `requirements.txt`.
    5.  **Создание конфигурации:** Создает на сервере файл `.env.production`, содержащий все секреты и настройки для продакшена.
    6.  **Настройка `systemd`:** Копирует файл сервиса и перезагружает `systemd`.
    7.  **Запуск и проверка:** Запускает сервис и проверяет его статус. В случае ошибки выводит подробные логи.

### 2.6. Пост-деплой проверки (`post_deploy_verification`)
*   **Триггер:** Только на коммиты в `main`, после успешного деплоя.
*   **Действие:** Еще раз подключается к серверу для финальной проверки: активен ли `systemd` сервис и на месте ли ключевые файлы.

### 2.7. Откат (`rollback_deployment`)
*   **Триггер:** **Вручную** из интерфейса GitLab.
*   **Действие:** Находит последний созданный бэкап, останавливает сервис, восстанавливает файлы из бэкапа и запускает сервис снова. Это позволяет быстро вернуться к предыдущей рабочей версии.

## 3. Используемые Инструменты и Технологии
*   **CI/CD система:** GitLab CI/CD.
*   **Исполнитель (Runner):** GitLab Runner с `docker` executor. Используются образы `python:3.9-slim` и `alpine:latest`.
*   **Скрипты:** `bash` (внутри `script` блоков).
*   **Управление зависимостями:** `pip` и `requirements.txt`.
*   **Тестирование:** `pytest`.
*   **Развертывание:** SSH, `scp`, `rsync`. Приложение запускается как `systemd` сервис на виртуальной машине.
*   **Конфигурация:** `.env` файлы (библиотека `python-dotenv`) и переменные GitLab CI/CD.

## 4. Предварительные Шаги для Запуска
Для работы пайплайна необходимо один раз настроить окружение:

1.  **Настроить GitLab Runner**, доступный для проекта, с тегом `docker`.
2.  **Настроить переменные в GitLab CI/CD** (`Settings -> CI/CD -> Variables`):
    *   `SSH_PRIVATE_KEY`: Приватный SSH-ключ для доступа к серверу. Рекомендуется тип `File` или `Variable` с base64-кодированным ключом.
    *   `DEPLOY_SERVER`: IP-адрес или доменное имя сервера.
    *   `DEPLOY_USER`: Имя пользователя для SSH-подключения, у которого есть `sudo` права.
3.  **Подготовить сервер:** Установить `python3`, `python3-venv`, `openssh-server` и `rsync`.

## 5. Руководство по Деплою
*   **Инициация:**
    *   Деплой на продакшн происходит автоматически при каждом коммите в ветку `main`.
    *   Для проверки кода без деплоя создайте Merge Request — это запустит только стадии `validate` и `test`.
*   **Отслеживание:**
    *   Прогресс можно отслеживать в разделе `CI/CD -> Pipelines` в вашем проекте GitLab.
    *   Для просмотра логов в реальном времени кликните на интересующую задачу (job).
*   **Реагирование на ошибки:**
    *   Если пайплайн падает, в первую очередь изучите лог провалившейся задачи. В нем будет указана точная команда и ошибка.
    *   Наиболее частые ошибки связаны с конфигурацией сервера, правами доступа или ошибками в самом приложении при запуске.
*   **Откат:**
    1.  Зайдите в `CI/CD -> Pipelines` и выберите последний (или нужный) пайплайн.
    2.  Перейдите на вкладку `Jobs`.
    3.  Найдите задачу `rollback_deployment` и нажмите на иконку "play" (▶️), чтобы запустить ее вручную.

## 6. Стандарты Безопасности и Best Practices
*   **Секреты:** Все чувствительные данные (ключи, пароли) хранятся в зашифрованных переменных GitLab CI/CD, а не в коде.
*   **Бэкапы:** Автоматическое создание бэкапа перед каждым деплоем.
*   **Изоляция:** Задачи выполняются в изолированных Docker-контейнерах.
*   **Минимальные привилегии:** Приложение на сервере работает от имени пользователя `www-data`, у которого нет лишних прав.
*   **Fail Fast:** Пайплайн спроектирован так, чтобы падать на ранних этапах (синтаксис, тесты, пред-проверки), экономя время и ресурсы.
*   **Сохранность данных:** База данных в production окружении исключена из процесса синхронизации файлов при деплое, что защищает её от случайного удаления.

## 7. Часто Возникающие Проблемы и Решения
*   **Проблема:** Пайплайн падает на этапе деплоя с ошибкой `Permission denied`.
    *   **Решение:** Убедитесь, что `DEPLOY_USER` имеет `sudo` права и может писать в `/var/www`. Проверьте права на директории на сервере.
*   **Проблема:** Ошибка `configparser.NoSectionError` при запуске сервиса.
    *   **Статус:** **ИСПРАВЛЕНО**. Эта проблема была решена переходом на `.env.production`, который создается при деплое. Убедитесь, что все необходимые переменные прописаны в `.gitlab-ci.yml` в блоке создания этого файла.
*   **Проблема:** База данных `blog.db` обнуляется после каждого деплоя.
    *   **Статус:** **ИСПРАВЛЕНО**. Ранее использовалась команда `rm -rf`, которая удаляла все файлы. Теперь используется `rsync` с исключением директории базы данных, что решает эту проблему.
*   **Проблема:** Ошибка с форматом `SSH_PRIVATE_KEY`.
    *   **Решение:** Пайплайн уже содержит скрипты для исправления формата ключа. Если проблема сохраняется, скопируйте ключ в переменную GitLab заново, убедившись в отсутствии лишних символов.

## 8. Примеры Конфигурационных Файлов

### `systemd` сервис (`flask-helpdesk.service`)
```ini
[Unit]
Description=Flask Helpdesk Application
After=network.target

[Service]
Type=exec
User=www-data
Group=www-data
WorkingDirectory=/var/www/flask_helpdesk
Environment=PATH=/var/www/flask_helpdesk/venv/bin
Environment=FLASK_ENV=production
Environment=PYTHONPATH=/var/www/flask_helpdesk
ExecStart=/var/www/flask_helpdesk/venv/bin/python wsgi.py
ExecReload=/bin/kill -s HUP $MAINPID
Restart=always
RestartSec=3
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
```

### Фрагмент пайплайна (Деплой)
```yaml
deploy_to_server:
  stage: deploy
  script:
    - # ... настройка SSH ...
    - ssh $DEPLOY_USER@$DEPLOY_SERVER "
        echo '💾 Создаем бэкап...'
        sudo cp -r $DEPLOY_PATH $BACKUP_PATH/backup_$(date +%Y%m%d_%H%M%S)

        echo '⏹️ Останавливаем сервис...'
        sudo systemctl stop $SERVICE_NAME
      "
    - # ... копирование и распаковка артефакта с помощью rsync ...
    - ssh $DEPLOY_USER@$DEPLOY_SERVER "
        echo '🐍 Настраиваем Python окружение...'
        cd $DEPLOY_PATH
        sudo python3 -m venv venv
        sudo -u www-data venv/bin/pip install -r requirements.txt

        echo '▶️ Запускаем сервис...'
        sudo systemctl start $SERVICE_NAME
      "
```
